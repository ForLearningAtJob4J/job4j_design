2, 3. Для определения размера объекта важны следующие флаги:
UseCompressedClassPointers - использовать сжатые указатели на класс
        (т.е. использовать 32-битные указатели вместо 64-битных на 64-разрядной JVM).
        bool UseCompressedClassPointers               = true                                 {lp64_product} {ergonomic}
UseCompressedOops - использовать сжатые указатели на объект (OOP = ordinary object pointer)
        (т.е. использовать 32-битные указатели вместо 64-битных на 64-разрядной JVM).
        bool UseCompressedOops                        = true                                 {lp64_product} {ergonomic}

ObjectAlignmentInBytes - выравнивание структур в памяти на кратный указанному размер в байтах.
        intx ObjectAlignmentInBytes                   = 8                                    {lp64_product} {default}

Размер объекта это
    размер заголовка
        markWord - метаинфо объекта (4/8 байтов (зависит от разрядности JVM))
        + klassWord - ссылка на класс
        (+ 4 байта размер массива, если этот объект - массив)
        (+ возможное выравнивание)
    размер полей
        + поля примитивных типов (если в заголовке есть выравнивание, то оно заполняется, в порядке размера типа,
                                    подходящими по размерам полями этих типов)
        (+ возможное выравнивание)
        + ссылки на поля-объекты (если в заголовке есть выравнивание и нет примитивных типов, либо примитивные
                                    толко 8-байтовые, то оно заполняется ссылкой на объект поля)
        (+ возможное выравнивание)

Узнать значения флагов можно, например,  установкой флага :) -XX:+PrintFlagsFinal в командной строке запуска приложения.

Заголовок пустого объекта в моем случае (64 разрядной JVM, указанные выше флаги - по умолчанию) 8 + 4 = 12, но так как
нужен размер кратный ObjectAlignmentInBytes, то еще добавляется 16 (ближайшее кратное).

Размер самого объекта User бует равен
 OFFSET  SIZE               TYPE DESCRIPTION                               VALUE
      0     4                    (object header)                           0d 00 00 00 (00001101 00000000 00000000 00000000) (13)
      4     4                    (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)
      8     4                    (object header)                           08 28 17 00 (00001000 00101000 00010111 00000000) (1517576)
     12     4                int User.age                                  1
     16     4   java.lang.String User.name                                 (object)
     20     4                    (loss due to the next object alignment)
Instance size: 24 bytes
,размер объекта строки
 OFFSET  SIZE      TYPE DESCRIPTION                               VALUE
      0    12           (object header)                           N/A
     12     4    byte[] String.value                              N/A
     16     4       int String.hash                               N/A
     20     1      byte String.coder                              N/A
     21     1   boolean String.hashIsZero                         N/A
     22     2           (loss due to the next object alignment)
Instance size: 24 bytes
и размер самого массива байтов (у меня строки в кодировке UTF-8) я для упрощения всем прописал слово Name.
В UTF-8 это будет 4 байта. (русские буквы будут занимать уже по два байта) ну и выравнивание
[B object internals:
 OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)
      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)
      8     4        (object header)                           fc 41 07 00 (11111100 01000001 00000111 00000000) (475644)
     12     4        (object header)                           04 00 00 00 (00000100 00000000 00000000 00000000) (4)
     16     4   byte [B.<elements>                             N/A
     20     4        (loss due to the next object alignment)
Instance size: 24 bytes
Итого 24 + 24 + 24 = 72 байта.

Еще, например, на стеке потока хранится указатель на объект. Т.е. в памяти, выделенной JVM для стека потока, он займёт
место. И еще много в каких служебных структурах JVM (Remembered Sets сборщика мусора, таблицы символов, таблицы
строк и пр.). Как для класса в целом, так и для для каждого объекта. Моих знаний не хватает на точный подсчёт.
Думаю, Андрей Паньгин, Алексей Шипилёв, Тагир Валеев и прочая подобная братия смогут, но не я, по-крайней мере,
пока что, точно )

4, 5. Если я правильно понял вопрос, нужно было добиться именно вызова финализатора, как в предыдущей лекции?
Или нужно было просто убедиться, что сборка была вызвана?
Указываем в командной строке флаг -Xlog:gc*:garbage-collection.log
Если нужно понять, сколько памяти нужно, чтобы сборка была вызвана хотя бы один раз, то  смотрим USED в конце лог-файла
[5.846s][info][gc,heap,exit ]  garbage-first heap   total 262144K, used 9216K [0x0000000701a00000, 0x0000000800000000)
в моем случае это 9216K.
Т.е. для 100% вызова сборщиком хотя бы одной сборки, например, (young), достаточно указать любую меньшую цифру (9m).

А для вызова деструктора, я так понял, для G1, нужно, чтобы регионы не использовались повторно, тогда этот сборщик не
будет непосредственно уничтожать мусорные объекты.